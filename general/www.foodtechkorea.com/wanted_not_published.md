# 하흥주

- {private info phone number}
- {private info email}
- https://github.com/ThePott
- https://velog.io/@nusilite/posts

## 일관되고 예측 가능해야 아름답다

푸드 테크는 외식 사업자 뿐 아니라 외식 서비스의 이용자를 돕는 기업입니다. 테이블 키오스크를 제공해 사업자는
외식업의 본질인 요리에 자원을 더 집중할 수 있게 하였고, 이용자는 보다 쉽게 주문, 결제를 하여 함께 식사하는 사람과의
시간에 더 몰입할 수 있게 하고 있습니다. 외식에서 본질을 제외한 모든 것을 예측 가능하게 바꾸었습니다.
이용자 모두가 모든 상황을 일관되게 대응할 수 있게 한 푸드테크의 서비스는 아름답습니다.

### 일관적이고 예측 가능한 구조

입시 학원 강사의 수업은 강사의 기억력과 그날의 컨디션에 좌우됩니다. 저는 강사로 재직하는 4년 반 동안, 파이썬의 pandas와 구글 시트를 이용해
강의의 품질을 일관되게 유지할 수 있는 시스템을 구축하고 사용했습니다.
구글 시트를 데이터베이스 삼아 교재 문제의 좌표(쪽 번호, 문제 번호 등)을 기록해두고 학생의 오답을 기록했습니다.
처음엔 리스트를 중첩해서 표를 데이터화 했던 것을, pandas로 개선하고 최초에만 사용하고 더 이상 쓰지 않는 기능을 삭제하여
오답 과제 생성 속도를 60초에서 30초로, 마지막엔 10초대로 줄였습니다. 이 시스템으로 기억에 의존하지 않고 학생들의 진도를 추적 관리할 수 있었습니다.
수업의 질을 더 높이고 싶어 1년 6개월 동안 5권의 교재를 집필하였으나, 사정상 판매도, 공개도 하지 못했습니다.
더 널리 쓰일 수 있는 도구를 만들고 싶어 강사 신분을 정리하고 개발자를 준비하게 되었습니다.
그 때나 지금이나 제 안의 아름다움의 기준은 범용성과 체계성입니다.
개발자를 준비하는 지금은 이를 "높은 재사용성"으로 대신해 말합니다.

### 아름다운 코드, 어우러지는 코드

퇴사 후 보다 체계적인 학습을 위해 오즈코딩스쿨 프론트엔드 과정을 수강하며, 내가 만든 코드를 어떻게 남들이 쓰기 쉽게 할 수 있을지를 고민했습니다.

처음엔 내가 재사용할 수 있으면 쓰기 좋은 코드라고 생각했습니다. 이에 첫 번째 팀 프로젝트 때에는 좋은 공통 컴포넌트, 함수를 만들어두기만 하였습니다.
다만, 팀원들에겐 남이 작성할 코드를 읽을 유인이 적었고, 이미 구현된 기능을 다시 구현하고 PR을 올렸습니다.
PR을 리뷰했던 저는, 해당 코드가 기능상 문제가 없으니 PR을 승인했습니다.
그러나 이러한 시간이 쌓여가자, 프로젝트 말미에는 HTTP 요청에 누구는 axios를 누구는 fetch를 썼고, 누구는 캐시를 낙관적으로 업데이트하고 누구는 새로 고침 전까지 업데이트를 하지 않았습니다.
낙관적 업데이트를 간단하게 해결하는 공통 후크를 제작했지만, 지금까지 제 코드를 읽어보고 써달라고 하지 않았었기에 팀원들은 제 코드를 이해하는 데에 어려움을 겪었습니다.
결국 이는 해결되지 않은 채 자체평가 7점으로 프로젝트는 마무리되었습니다.

이를 교훈 삼아 두 번째 프로젝트에서는 공통 컴포넌트를 팀원들이 이해하고 사용하기 쉽게 하는 작업에 집중했습니다.
설명 주석 뿐 아니라, 셀렉터를 비롯한 핵심 공통 컴포넌트 7개의 사용 예시 코드, 컴포넌트의 모든 속성을 한 눈에 확인할 수 있는 테스트 페이지를 제작하였습니다.
덕분에 팀원들은 코드를 한 줄 한 줄 읽으며 이해할 필요 없이, 사용 예시, 화면 상 구현 결과를 보며 직관적으로 사용법을 파악할 수 있었습니다.
이런 노력이 보답을 받아, 해당 프로젝트에선 모든 팀원들이 개발 과정과 결과를 만족스럽게 생각하고 10점 만점에 10점으로 평가를 했습니다.

### I use NeoVim, by the way

결과가 아름다우려면 과정도 아름다워야 하고, 과정이 아름다우려면 사용하는 도구도 아름다워야 합니다.
저는 문제를 해결하는 코드를 작성하는 데에 집중하고 싶습니다. 그러나 실제 코드를 작성할 때, 정말 많은 개발자들이 정말 많은 시간을,
파일과 애플리케이션을 이동하는 데에 시간을 씁니다. 저는 파일 트리에서 그 파일이 어디 있는지, 미션 컨트롤로 펼쳐 놓은 수 많은
앱 중, 내가 브라우저가 어떤 것인지를 찾는 시간 동안 코드를 작성하고 싶었습니다. 작업 환경을 저에게 최적화를 하기 위해서 저는
3초 걸리던 NeoVim으로 파일 간 전환, 코드 줄 간 이동 시간을 단축키 하나로 해결하여 소요 시간을 0.5초 미만으로, 84퍼센트 이상 축소했습니다. 이로써 화면 전환 간 파일 탐색을
하느라 집중력이 흐트러지는 문제를 해결했습니다. 아름다운 도구를 사용하기에 저는 오늘도 즐겁게 코딩을 했습니다.

저의 미학을 푸드테크에 전하고 싶습니다. 그리고 푸드테크의 미학을 경험하고 싶습니다.

## 핵심 프로젝트

### 스터디 트래커

위에서 말한 진도 관리 시스템은 pandas, 불필요한 기능 제거를 통해 10초대로 과제 생성 시간을 줄였습니다.
파이참이 없어도 누구나 편하게 사용하게 하고 싶어 이를 웹 서비스로 개발을 했습니다.
이 과정에서 아래와 같은 문제들이 발생했습니다.

**데이터베이스**

1. 구글 시트는 1,000만 셀 이상의 데이터를 담을 수 없습니다. 해당 시스템 운용한 지 2년 차부터 용량의 한계에 도달했습니다.
2. 한 번에 조작하는 것은 80행 정도였습니다. 이 정도의 데이터를 조작하는 데에 10초는 너무 길었습니다.

이를 해결하기 위해서 데이터베이스를 도입했습니다. iOS 독학 시절, MongoDB를 사용해보았기에 본 프로젝트에서도 이를 적용했습니다.
다만, "문제집 - 대단원 - 중단원 - 쪽 번호 - 문제"로 이어지는 계층 구조를 NoSQL로 만들다보니, 필요한 부분만 추출하기가 어려웠습니다.
이미 구글 시트에서 데이터가 정형화한 지금은 스키마에서 자유로운 NoSQL보다, 테이블과 테이블을 연결하는 SQL이 더 적합할 것으로 판단했습니다.
이에 PostgreSQL 기반의 Neon을 도입하였습니다.

<!-- 성능 비교 방법: 오답 입력 -> 오답과제 db 생성까지의 시간(pdf 생성 시간은 제외) -->

**데이터 입력**

1. 학생들은 인쇄된 오답체크표에 오답을 체크해 제출하면 제가 그것들을 수업 전에 취합해서 구글 시트에 옮겼습니다.
   학생들에게 구글 시트에 직접 기입을 시킬 수가 없기에 제가 매 수업 12명의 학생 오답을 기입하는 데에만 1시간 반에서 2시간이 걸렸습니다.

이 시간을 줄이고자 학생들이 직접 오답을 기입하기 좋은 UI를 만들었습니다.
학생들이 오답을 체크하는 데에 필요한 정보만 남기고 그리드 형태의 체크박스를 만들었습니다.
이에 한 수업동안 푸는 40여문제를 한 화면에서 체크할 수 있도록 했습니다.

**데이터 입력\_\_성능 이슈 발생**

오답을 체크할 땐 푼 문제 전체를 맞았다고 하고 그 중에서 틀린 문제를 다시 체크하는 것이 일반적입니다.
이를 위해 호텔앱에서 숙박일 선택을 할 때처럼 시작 셀과 종료 셀을 클릭하면 그 중간 전체가 선택이 되도록 하였습니다.
다만, 선택을 하면 2초가 지나 선택 셀의 색깔이 바뀌는 문제가 있었습니다. 원인은 아래와 같았습니다.

1. 전역 상태로 최근 2번의 클릭된 셀의 인덱스를 저장합니다.
2. 1000여개의 셀은 위의 셀 인덱스가 변할 때마다 둘 사이에 자신의 인덱스가 있는지 확인했습니다.

모든 체크박스가 전역 상태를 구독하고 있었고 체크를 할 때마다 모든 체크박스가 리렌더되었습니다.
이 때문에 아무리 적게 선택을 해도 전체 리렌더에 때문에 2초의 시간이 걸린 후에 UI가 변경되었습니다.

이를 해결하기 위해 아래의 방법을 사용했습니다.

1. 반복되는 자식 컴포넌트 중 누가 선택되었는지는 자식이 아닌 부모 단에서 계산하고 이 결과를 자식에게 원시 자료 형태로 내렸습니다.
2. React.memo로 감싸진 자식 컴포넌트는 부모에게 받는 속성이 변하지 않는 한 리렌더가 되지 않았습니다.

이를 이용해 일반적인 다중 선택(40여개)의 소요 시간이 0.5초 이내로, 75% 이상 단축하였습니다. 이는 `console.time`으로 측정했습니다.

**진도표 갱신 규격화**

기존엔 구글 시트에 진도표를 넣고 상황에 맞게 전 숙제, 오늘 할당량, 새 숙제를 기록하였습니다.
각 파트의 상태가 위의 셋 밖에 없었기에 이를 칸반으로 관리하면 좋겠다고 생각했습니다.
이에 `React DnD` 라이브러리를 사용해 해당 기능을 구현하려고 하였으나, 칸반을 드래그할 때 불규칙적으로 `Maximum update depth exceeded`가 발생했습니다.
해당 드래그 중인 상태에 칸반에서 사용하는 객체 전체를 입력하였는데, 매 프레임 계산되는 드래그 앤 드롭 특성상 무거운 객체 때문에 오류가 발생하는 것이었습니다.
이를 해결하고자 칸반에 사용되는 객체의 id만을 드래그 중인 상태에 입력하였고, 해당 객체는 이후 전역 상태에서 꺼내서 검색하는 식으로 구조를 변경하였습니다.
이후는 드래그 앤 드롭이 정상적으로 작동하였습니다.

### 온라인 스터디 커뮤니티 StudyHub 강의, 구인 공고 파트

<!--문제 및 핵심 기술-->
<!-- 1. 마운트마다 요청 -> 캐시 관리 -> 응답, 에러 요청관리 단순화 -> TanStack Query -> 낙관적 업데이트로 자료 신선하게 -->
<!-- 2. 무한 스크롤 -> 브라우저 내장 API IntersectionObserver -> 모달에선 targetRef 인식 안 됨 -> 기본 root가 뷰포트(화면 전체)인데 모달은 화면 중 일부여서 -> rootRef를 공통 후크의 매개변수로 설정하여 해결 -->
<!-- 3. 마크다운 에디터로 필요 기능이 모두 있는 react-md-editor -> 스타일을 변경할 속성이 없음 -> 개발자 도구에서 클래스 네임 일일이 확인 -> css !important로 덮어씌움 -> 그래도 `textarea` 밑의 회색 선 안 없어짐 -> 개발자 도구에서 색깔 있는 걸 모두 끄며 확인, border, outline이 아닌 box-shadow였음 -->
<!-- 4. presigned-url CORS 에러: SWAG 문서에서의 요구사항을 맞췄는데도 CORS 에러. axios의 인터셉터를 이용해 항상 액세스 토큰을 헤더에 주입한 것이 문제. 해당 api에서는 Authorization 헤더를 허용하지 않았었음. 이를 고치자 204 응답을 받았지만 CORS 에러. 이건 Allowed-Origin이 * 와일드카드로 설정이 되어 있어서. 백엔드에서 이를 해결해주자 정상적으로 응답 받음-->
